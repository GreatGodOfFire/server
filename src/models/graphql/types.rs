use async_graphql::{Context, InputObject, Object, SimpleObject, Union, ID};
use sequoia_openpgp::{serialize::SerializeInto, Cert};

use crate::Config;

use super::scalars::{Bytes, DateTime};

////// Types //////
///// Output Types /////
pub(crate) struct PublicCertificate {
    pub(super) cert: Cert,
}

#[Object]
/// Represents a Certificate without secret parts
impl PublicCertificate {
    pub(crate) async fn fingerprint(&self) -> String {
        self.cert.fingerprint().to_hex()
    }

    pub(crate) async fn content(&self) -> Bytes {
        Bytes(bytes::Bytes::from(
            self.cert
                .to_vec()
                .expect("Certificate from the database is valid"),
        ))
    }
}

pub(crate) struct PrivateCertificate {
    pub(super) cert: Cert,
}

#[Object]
/// Represents a Certificate with encrypted secret parts
impl PrivateCertificate {
    pub(crate) async fn fingerprint(&self) -> String {
        self.cert.fingerprint().to_hex()
    }

    /// The encrypted Certificate. In order for the secret parts to be used, the stretched master key is needed.
    pub(crate) async fn content(&self) -> Bytes {
        Bytes(bytes::Bytes::from(
            self.cert
                .to_vec()
                .expect("Certificate from the database is valid"),
        ))
    }
}
pub(crate) struct Server {
    // config: Config
}

#[Object]
/// A server is an instance of the backend not a guild. It has a PGP Certificate like any normal User
impl Server {
    pub(crate) async fn id(&self) -> ID {
        ID("dummy id".to_string())
    }

    pub(crate) async fn certificate(&self, ctx: &Context<'_>) -> PublicCertificate {
        PublicCertificate {
            cert: ctx.data::<Config>().unwrap().server_cert.0.clone(),
        }
    }

    pub(crate) async fn name(&self) -> String {
        "dummy name".to_string()
    }
}

pub(crate) struct User {}

#[Object]
/// A normal user
impl User {
    pub(crate) async fn id(&self) -> ID {
        ID("dummy id user".to_string())
    }

    pub(crate) async fn certificate(&self, ctx: &Context<'_>) -> PublicCertificate {
        PublicCertificate {
            cert: ctx.data::<Config>().unwrap().server_cert.0.clone(),
        }
    }

    pub(crate) async fn name(&self) -> String {
        "dummy name user".to_string()
    }
}

#[derive(SimpleObject)]
/// Used for the response after a successful authentication
pub(crate) struct AuthenticatedUser {
    pub(crate) id: ID,
    pub(crate) name: String,
    /// Since the client needs the secret parts of the PGP Certificate, the server sends them to the client for decryption
    pub(crate) certificate: PrivateCertificate,
}
///// Input Types /////
#[derive(InputObject)]
/// The information the server needs for the signup process
pub(crate) struct SignupUserInput {
    /// The name the user wants to use for login etc. If not set, the first identity of the PGP Certificate is used.
    pub(crate) name: Option<String>,
    /// The master password hash derived from the master password
    pub(crate) hash: Bytes,
    /// The PGP Certificate WITH encrypted secret parts generated by the client
    pub(crate) certificate: Bytes, // PrivateCertificate is not an input type, so Bytes have to do
    /// A random challenge obtained by calling the getChallenge query signed by the primary key of the Certificate.
    /// Used to proof that the client has the control over the Certificate's primary key and therefore the whole Certificate.
    pub(crate) challenge: Bytes,
}

#[derive(InputObject)]
/// Used for the login credentials
pub(crate) struct AuthenticationCredentialsUserInput {
    /// The name of the user used to login
    pub(crate) name: String,
    /// the master password hash derived from the master password
    pub(crate) hash: Bytes,
}

////// Result types (unions) //////
///// Signup Result /////
#[derive(SimpleObject)]
/// Used to have typed error types
pub(crate) struct SignupResult {
    /// The generated User for the client to get its id. If there is an error, it should be null
    pub(crate) user: Option<User>,
    /// The errors that may have occured. If there were no errors, it is empty ([]) NOT null
    pub(crate) errors: Vec<SignupError>,
}

///// Authentication Result /////
#[derive(SimpleObject)]
pub(crate) struct AuthenticationResult {
    // Returns the AuthenticatedUser with the Certificate WITH encrypted secret parts
    pub(crate) user: Option<AuthenticatedUser>,
    /// The errors that may have occured. If there were no errors, it is empty ([]) NOT null
    pub(crate) errors: Vec<AuthenticationError>,
}
////// Error types //////
///// Signup Errors /////
#[derive(Union)]
/// All error that can occur during signup
pub(crate) enum SignupError {
    UsernameUnavailable(UsernameUnavailable),
    CertificateTaken(CertificateTaken),
    InvalidSignature(InvalidSignature),
}

#[derive(SimpleObject)]
/// The username is already taken or unavailable for other reasons
pub(crate) struct UsernameUnavailable {
    pub(crate) description: String,
}

#[derive(SimpleObject)]
/// Another user's certificate has the same fingerprint.
/// This error is normally almost impossible but can happen if the client tries to use the same certificate twice.
pub(crate) struct CertificateTaken {
    pub(crate) description: String,
}

#[derive(SimpleObject)]
/// The certificate malformed or something similar
pub(crate) struct InvalidCetificate {
    pub(crate) description: String,
}

#[derive(SimpleObject)]
/// The certification of the server's PGP Certificate is invalid
pub(crate) struct InvalidSignature {
    pub(crate) description: String,
}

///// Authentication Errors /////
#[derive(Union)]
/// All errors that can occur during authentication/login
pub(crate) enum AuthenticationError {
    UnknownUser(UnknownUser),
    InvalidMasterPasswordHash(InvalidMasterPasswordHash),
    UserSuspended(UserSuspended),
}

#[derive(SimpleObject)]
/// The username is unknown
pub(crate) struct UnknownUser {
    pub(crate) description: String,
}

#[derive(SimpleObject)]
/// The master password hash derived from the master password is invalid
pub(crate) struct InvalidMasterPasswordHash {
    pub(crate) description: String,
}

#[derive(SimpleObject)]
/// The user is suspended
pub(crate) struct UserSuspended {
    pub(crate) description: String,
    /// the date the user got suspended
    pub(crate) since: Option<DateTime>,
    /// the reason for the suspension
    pub(crate) reason: Option<String>,
}
